import basic;

// ActionData

table ActionData {
    action: Bytes,
    params: Bytes,
}

// ConfigCellData

table ConfigCellMain {
    // the grace period for account expiration in seconds
    account_expiration_grace_period: Uint32,
    // the minimum ttl of record in seconds
    min_ttl: Uint32,
    // table of type ID of all kinds of cells
    type_id_table: TypeIdTable,
}

table TypeIdTable {
    apply_register_cell: Hash,
    pre_account_cell: Hash,
    proposal_cell: Hash,
    ref_cell: Hash,
    account_cell: Hash,
    on_sale_cell: Hash,
    bidding_cell: Hash,
    primary_market_cell: Hash,
    wallet_cell: Hash,
}

table ConfigCellRegister {
    // The minimum waiting block number before apply_register_cell can be converted to pre_account_cell.
    apply_min_waiting_block_number: Uint32,
    // The maximum waiting block number which apply_register_cell can be converted to pre_account_cell.
    apply_max_waiting_block_number: Uint32,
    // The length of accounts in bytes.
    account_max_length: Uint32,
    // available char sets for account
    char_sets: CharSetList,
    // Price list of different account length.
    price_configs: PriceConfigList,
    // How many blocks required for every proposal to be confirmed.
    proposal_min_confirm_interval: Uint8,
    // How many blocks to wait before extending the proposal.
    proposal_min_extend_interval: Uint8,
    // How many blocks to wait before recycle the proposal.
    proposal_min_recycle_interval: Uint8,
    // How many account_cells every proposal can affect.
    proposal_max_account_affect: Uint32,
    // How many pre_account_cells be included in every proposal.
    proposal_max_pre_account_contain: Uint32,
    // profit configurations
    profit: ProfitConfig,
}

vector PriceConfigList <PriceConfig>;

table PriceConfig {
  // The length of the account, ".bit" suffix is not included.
  length: Uint8,
  // The price of registering an account. In USD, accurate to 6 decimal places.
  new: Uint64,
  // The price of renewing an account. In USD, accurate to 6 decimal places.
  renew: Uint64,
}

vector CharSetList <CharSet>;

table CharSet {
    name: Uint32,
    global: Uint8,
    chars: Chars,
}

vector Chars <Bytes>;

table ProfitConfig {
    // The profit rate of inviters who invite people to buy DAS accounts.
    profit_rate_of_inviter: Uint32,
    // The profit rate of channels who support people to create DAS accounts.
    profit_rate_of_channel: Uint32,
    // The profit rate of DAS itself.
    profit_rate_of_das: Uint32,
}

table ConfigCellMarket {
    // primary market configurations
    primary_market: MarketConfig,
    // primary market configurations
    secondary_market: MarketConfig,
}

table MarketConfig {
    // The maximum time, in seconds, that an account in a sale can exist in the market.
    max_selling_time: Uint32,
    // The maximum time, in seconds, that an account in an auction can exist in the market.
    max_auction_time: Uint32,
    // The maximum time, in seconds, that an account in an auction waits before it closes.
    max_auction_waiting: Uint32,
    // The minimum percentage of raise at each bid in the auction.
    min_auction_raise_rate: Uint32,
}

// ProposalCellData

table ProposalCellData {
    proposer_lock: Script,
    proposer_wallet: Bytes,
    slices: SliceList,
}

vector SliceList <SL>;

// SL is used here for "slice" because "slice" may be a keyword in some languages.
vector SL <ProposalItem>;

table ProposalItem {
  // When account is the root of the linked list, its account_id should be 0x0000... .
  account_id: AccountId,
  item_type: Uint8,
  // When account is at the end of the linked list, its next pointer should be 0xffff... .
  next: AccountId,
}

// AccountCellData

table AccountCellData {
    // The first 160 bits of the hash of account.
    id: AccountId,
    // The lock script of owner.
    owner_lock: Script,
    // The lock script of manager.
    manager_lock: Script,
    // Separate chars of account.
    account: AccountChars,
    // AccountCell register timestamp.
    registered_at: Uint64,
    // The status of the account, 0x00 means normal, 0x01 means being sold, 0x02 means being auctioned.
    status: Uint8,
    records: Records,
}

array AccountId [byte; 10];

table Record {
    record_type: Bytes,
    record_label: Bytes,
    record_key: Bytes,
    record_value: Bytes,
    record_ttl: Uint32,
}

vector Records <Record>;

// PreAccountCellData

table PreAccountCellData {
    // Separate chars of account.
    account: AccountChars,
    // If the PreAccountCell cannot be registered, this field specifies to whom the refund should be given.
    refund_lock: Script,
    // If the PreAccountCell is registered successfully, this field specifies to whom the account should be given.
    owner_lock: Script,
    // The wallet ID of inviter,
    inviter_wallet: Bytes,
    // The wallet ID of channel,
    channel_wallet: Bytes,
    // Price of the account at the moment of registration.
    price: PriceConfig,
    // The exchange rate between CKB and USD.
    quote: Uint64,
    created_at: Timestamp,
}

vector AccountChars <AccountChar>;

table AccountChar {
    // Name of the char set which the char belongs.
    char_set_name: Uint32,
    // Bytes of the char.
    bytes: Bytes,
}

// OnSaleCellData

table OnSaleCellData {
    // the price of account
    price: Uint64,
    // the timestamp when sale starting
    started_at: Uint64,
}

// BiddingCellData

table BiddingCellData {
    // market type, 0x01 for primaryï¼Œ0x02 for secondary
    market_type: Uint8,
    // starting bidding price in USD
    starting_price: Uint64,
    // current bidding price in USD
    current_price: Uint64,
    // latest bidder's lock script
    current_bidder: ScriptOpt,
    // the timestamp when sale starting
    started_at: Uint64,
}
