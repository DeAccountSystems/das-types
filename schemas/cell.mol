import basic;

// ActionData

table ActionData {
    action: Bytes,
    params: Bytes,
}

// ConfigCellData

table ConfigCellData {
    // bloom filter bits array of approximately 200 KB
    reserved_account_filter: Bytes,
    // How many blocks required for every proposal to be confirmed.
    proposal_min_confirm_require: Uint8,
    // How many blocks to wait before extending the proposal.
    proposal_min_extend_interval: Uint8,
    // How many account_cells every proposal can affect.
    proposal_max_account_affect: Uint32,
    // How many pre_account_cells be included in every proposal.
    proposal_max_pre_account_contain: Uint32,
    // The minimum waiting seconds before apply_register_cell can be converted to pre_account_cell.
    apply_min_waiting_time: Uint32,
    // The maximum waiting seconds which apply_register_cell can be converted to pre_account_cell.
    apply_max_waiting_time: Uint32,
    // The length of accounts in bytes.
    account_max_length: Uint32,
    // lock script of working keeper who aggregate the votes
    price_configs: PriceConfigList,
    // available char sets for account
    char_sets: CharSetList,
    // the minimum ttl of record
    min_ttl: Uint32,
    // the closing limit of primary market auction(seconds)
    closing_limit_of_primary_market_auction: Uint32,
    // the closing limit of secondary market auction(seconds)
    closing_limit_of_secondary_market_auction: Uint32,
    // table of type ID of all kinds of cells
    type_id_table: TypeIdTable,
}

vector PriceConfigList <PriceConfig>;

table PriceConfig {
  length: Uint8,
  new: Uint64,
  renew: Uint64,
}

vector CharSetList <CharSet>;

table CharSet {
    name: Uint32,
    global: Uint8,
    chars: Chars,
}

vector Chars <Bytes>;

table TypeIdTable {
    apply_register_cell: Hash,
    pre_account_cell: Hash,
    proposal_cell: Hash,
    ref_cell: Hash,
    account_cell: Hash,
    on_sale_cell: Hash,
    bidding_cell: Hash,
    primary_market_cell: Hash,
}

// ProposalCellData

table ProposalCellData {
    starter_lock: Script,
    slices: SliceList,
}

vector SliceList <SL>;

// SL is used here for "slice" because "slice" may be a keyword in some languages.
vector SL <ProposalItem>;

table ProposalItem {
  account_id: AccountId,
  item_type: Uint8,
  // When account is at the end of the linked list, its next pointer should be None.
  next: AccountIdOpt,
}

// AccountCellData

table AccountCellData {
    // The first 160 bits of the hash of account.
    id: AccountId,
    // The lock script of owner.
    owner: Script,
    // The lock script of manager.
    manager: Script,
    account: Bytes,
    // The status of the account, 0x00 means normal, 0x01 means being sold, 0x02 means being auctioned.
    status: Uint8,
    registered_at: Timestamp,
    expired_at: Timestamp,
    records: Records,
}

array AccountId [byte; 20];

option AccountIdOpt (AccountId);

table Record {
    record_type: Bytes,
    record_label: Bytes,
    record_value: Bytes,
    record_ttl: Uint32,
}

vector Records <Record>;

// PreAccountCellData

table PreAccountCellData {
    account: Bytes,
    // If the PreAccountCell cannot be registered, this field specifies to whom the refund should be given.
    refund_lock: Script,
    // If the PreAccountCell is registered successfully, this field specifies to whom the account should be given.
    owner_lock: Script,
    // Price of the account at the moment of registration.
    price: PriceConfig,
    // The exchange rate between CKB and USD.
    quote: Uint32,
    created_at: Timestamp,
}

// OnSaleCellData

table OnSaleCellData {
    // the price of account
    price: Uint64,
}

// BiddingCellData

table BiddingCellData {
    // market type, 0x01 for primaryï¼Œ0x02 for secondary
    market_type: Uint8,
    // starting bidding price
    starting_price: Uint64,
    // current bidding price
    current_price: Uint64,
    // latest bidder's lock script
    current_bidder: ScriptOpt,
}
