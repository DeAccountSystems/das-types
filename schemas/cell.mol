import basic;

// ActionData

table ActionData {
    action: Bytes,
    params: Bytes,
}

// ConfigCellData

table ConfigCellMain {
    // Global DAS system switch, 0x01 means system on, 0x00 means system off.
    status: Uint8,
    // table of type ID of all kinds of cells
    type_id_table: TypeIdTable,
    // table code_hash of dynamic libs of das-lock
    das_lock_out_point_table: DasLockOutPointTable,
}

table TypeIdTable {
    account_cell: Hash,
    apply_register_cell: Hash,
    balance_cell: Hash,
    income_cell: Hash,
    pre_account_cell: Hash,
    proposal_cell: Hash,
    account_sale_cell: Hash,
    account_auction_cell: Hash,
}

table DasLockOutPointTable {
    ckb_signall: OutPoint,
    ckb_multisign: OutPoint,
    ckb_anyone_can_pay: OutPoint,
    eth: OutPoint,
    tron: OutPoint,
}

table ConfigCellAccount {
    // The maximum length of accounts in characters.
    max_length: Uint32,
    // The basic capacity AccountCell required, it is bigger than or equal to AccountCell occupied capacity.
    basic_capacity: Uint64,
    // The fees prepared for various transactions for operating an account.
    prepared_fee_capacity: Uint64,
    // The grace period for account expiration in seconds
    expiration_grace_period: Uint32,
    // The minimum ttl of record in seconds
    record_min_ttl: Uint32,
    // The maximum size of all records in molecule encoding
    record_size_limit: Uint32,
    // The fee of each action
    transfer_account_fee: Uint64,
    edit_manager_fee: Uint64,
    edit_records_fee: Uint64,
    // The frequency limit of actions which manipulating account
    transfer_account_throttle: Uint32,
    edit_manager_throttle: Uint32,
    edit_records_throttle: Uint32,
}

table ConfigCellApply {
    // The minimum waiting block number before apply_register_cell can be converted to pre_account_cell.
    apply_min_waiting_block_number: Uint32,
    // The maximum waiting block number which apply_register_cell can be converted to pre_account_cell.
    apply_max_waiting_block_number: Uint32,
}

vector Chars <Bytes>;

table ConfigCellPrice {
    // discount configurations
    discount: DiscountConfig,
    // Price list of different account length.
    prices: PriceConfigList,
}

table DiscountConfig {
    // The discount rate for invited user
    invited_discount: Uint32,
}

vector PriceConfigList <PriceConfig>;

table PriceConfig {
  // The length of the account, ".bit" suffix is not included.
  length: Uint8,
  // The price of registering an account. In USD, accurate to 6 decimal places.
  new: Uint64,
  // The price of renewing an account. In USD, accurate to 6 decimal places.
  renew: Uint64,
}

table ConfigCellProposal {
    // How many blocks required for every proposal to be confirmed.
    proposal_min_confirm_interval: Uint8,
    // How many blocks to wait before extending the proposal.
    proposal_min_extend_interval: Uint8,
    // How many blocks to wait before recycle the proposal.
    proposal_min_recycle_interval: Uint8,
    // How many account_cells every proposal can affect.
    proposal_max_account_affect: Uint32,
    // How many pre_account_cells be included in every proposal.
    proposal_max_pre_account_contain: Uint32,
}

table ConfigCellProfitRate {
    // The profit rate of inviters who invite people to buy DAS accounts.
    inviter: Uint32,
    // The profit rate of channels who support people to create DAS accounts.
    channel: Uint32,
    // The profit rate for who created proposal
    proposal_create: Uint32,
    // The profit rate for who confirmed proposal
    proposal_confirm: Uint32,
    // The profit rate for consolidating IncomeCells
    income_consolidate: Uint32,
    // The profit rate for inviter in account sale.
    sale_inviter: Uint32,
    // The profit rate for channel in account sale.
    sale_channel: Uint32,
    // The profit rate for DAS in account sale.
    sale_das: Uint32,
}

table ConfigCellIncome {
    // The basic capacity IncomeCell required, it is bigger than or equal to IncomeCell occupied capacity.
    basic_capacity: Uint64,
    // The maximum records one IncomeCell can hold.
    max_records: Uint32,
    // The minimum capacity which determines whether a record should be transferred.
    min_transfer_capacity: Uint64,
}

table ConfigCellRelease {
    // Release datetime for accounts of different length.
    release_rules: ReleaseRules,
}

vector ReleaseRules <ReleaseRule>;

table ReleaseRule {
    length: Uint32,
    release_start: Timestamp,
    release_end: Timestamp,
}

table ConfigCellSecondaryMarket {
    // Minimum price for selling an account.
    min_sale_price: Uint64,
    // Expiration time limit for selling accounts.
    sale_expiration_limit: Uint64,
    // Limitation of bytes size for the description of selling accounts.
    sale_description_bytes_limit: Uint32,
}

table ConfigCellAuction {
    // default 7 days = 7 * 86400 seconds
    max_duration: Uint64,

    min_bid_price: Uint64,

    default_increment_ratio: Uint64,

    // the commission rate given to the seller
    seller_commission_rate: Uint64,

    // the commission rate given to the last bidder
    last_bidder_commission_rate: Uint64,

    inviter_commission_rate: Uint64,

    channel_commission_rate: Uint64,
}

// ProposalCellData

table ProposalCellData {
    proposer_lock: Script,
    created_at_height: Uint64,
    slices: SliceList,
}

vector SliceList <SL>;

// SL is used here for "slice" because "slice" may be a keyword in some languages.
vector SL <ProposalItem>;

table ProposalItem {
  // When account is the root of the linked list, its account_id should be 0x0000... .
  account_id: AccountId,
  item_type: Uint8,
  // When account is at the end of the linked list, its next pointer should be 0xffff... .
  next: AccountId,
}

// IncomeCellData

table IncomeCellData {
    creator: Script,
    records: IncomeRecords,
}

vector IncomeRecords <IncomeRecord>;

table IncomeRecord {
    belong_to: Script,
    capacity: Uint64,
}

// AccountCellData

table AccountCellDataV1 {
    // The first 160 bits of the hash of account.
    id: AccountId,
    // Separate chars of account.
    account: AccountChars,
    // AccountCell register timestamp.
    registered_at: Uint64,
    // AccountCell update timestamp.
    updated_at: Uint64,
    // The status of the account, 0x00 means normal, 0x01 means being sold, 0x02 means being auctioned.
    status: Uint8,
    records: Records,
}

table AccountCellData {
    // The first 160 bits of the hash of account.
    id: AccountId,
    // Separate chars of account.
    account: AccountChars,
    // AccountCell register timestamp.
    registered_at: Uint64,
    // AccountCell last action timestamp.
    last_transfer_account_at: Timestamp,
    last_edit_manager_at: Timestamp,
    last_edit_records_at: Timestamp,
    // The status of the account, 0x00 means normal, 0x01 means being sold, 0x02 means being auctioned.
    status: Uint8,
    records: Records,
}

array AccountId [byte; 20];

table Record {
    record_type: Bytes,
    record_key: Bytes,
    record_label: Bytes,
    record_value: Bytes,
    record_ttl: Uint32,
}

vector Records <Record>;

// AccountSaleCellData

table AccountSaleCellData {
    // Account ID of associated account.
    account_id: AccountId,
    // The price user willing to sell the account.
    price: Uint64,
    // A customizable description for the account.
    description: Bytes,
    // timestamp of account sale start.
    started_at: Uint64,
}

// PreAccountCellData

table PreAccountCellData {
    // Separate chars of account.
    account: AccountChars,
    // If the PreAccountCell cannot be registered, this field specifies to whom the refund should be given.
    refund_lock: Script,
    // If the PreAccountCell is registered successfully, this field specifies to whom the account should be given.
    owner_lock_args: Bytes,
    // The account ID of inviter, it will not be used for any verification, just for front-end identification.
    inviter_id: Bytes,
    // The lock script of inviter.
    inviter_lock: ScriptOpt,
    // The lock script of channel.
    channel_lock: ScriptOpt,
    // Price of the account at the moment of registration.
    price: PriceConfig,
    // The exchange rate between CKB and USD.
    quote: Uint64,
    // The discount rate for invited user
    invited_discount: Uint32,
    created_at: Timestamp,
}

vector AccountChars <AccountChar>;

table AccountChar {
    // Name of the char set which the char belongs.
    char_set_name: Uint32,
    // Bytes of the char.
    bytes: Bytes,
}

// AccountAuctionCellData

table AccountAuctionCellData {
    account_id: AccountId,

    description: Bytes,

    // the opening price of the auction in CKB
    opening_price: Uint64,

    // a percentage based on 10000
    increment_ratio: Uint64,

    started_at: Timestamp,

    ended_at: Timestamp,

    // current bidder's lock script
    bidder: ScriptOpt,

    // current bidder's offer price
    bid_price: Uint64,
}